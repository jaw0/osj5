#!/usr/local/bin/perl
# -*- perl -*-

# Copyright (c) 2013
# Author: Jeff Weisberg <jaw @ tcp4me.com>
# Created: 2013-Mar-28 21:15 (EDT)
# Function: 
#
# $Id$

use strict;

my $file = shift @ARGV;

my $START = 32;
my $LAST  = 146;

(my $base = $file) =~ s|.*/||;
(my $fontname = "$base") =~ s/\..*//;
# RSN - clean name more...?

open(F, $file) || die "cannot open $file: $!\n";

my %CHARNAME;
while(<DATA>){
    s/\s+#.*//;
    my($c, $name) = /^(\S+)\s+(.*)/;
    $CHARNAME{$c} = $name;
}


my($bbx, $bby, $ox, $oy);
my($cbx, $cby, $cox, $coy);

my $cchar;
my @bitmap;
my %font;

print "\n// file: $file\n";

while(<F>){
    chop;
    my($k, $v) = split /\s+/, $_, 2;

    if( $k eq 'FONT' ){ print "// font: $v\n"; next; }
    if( $k eq 'FONTBOUNDINGBOX' ){
        ($bbx, $bby, $ox, $oy) = split /\s+/, $v;
        next;
    }
    if( $k eq 'STARTCHAR' ){
        $cchar = $v;
        next;
    }
    if( $k eq 'BBX' ){
        ($cbx, $cby, $cox, $coy) = split /\s+/, $v;
        next;
    }
    if( $k eq 'BITMAP' ){
        while(<F>){
            chop;
            last if /ENDCHAR/;
            # RSN - shift for cox
            #print STDERR ">>$_\n" if length($_) > 8;
            push @bitmap, hex($_);
        }
        # shift up/down
        if( $cby + $coy < $bby + $oy ){
            unshift @bitmap, 0 for (1 .. $bby + $oy - $cby - $coy);
        }

        $font{ $cchar } = [@bitmap];
        #print STDERR "$cchar => @bitmap\n";
        @bitmap = ();
        $cchar  = '';
    }
}

my $chbytes = 1;
$chbytes = 2 if $bby > 8;
$chbytes = 4 if $bby > 16;

my $xbits = 8;
$xbits = 16 if $bbx > 8;
$xbits = 32 if $bbx > 16;

print <<EOH;

#include <font.h>

const struct Font font_${fontname} = {
    .name	= "$fontname",
    .height	= $bby,
    .width	= $bbx,
    .byteschar	= $chbytes,
    .startchar  = $START,
    .lastchar	= $LAST,
    .data       = {
EOH
;

# print join(' ', keys %font), "\n";

for my $n ($START .. $LAST){
    mkglyph( $n );
}

print "    }\n";
print "};\n";
exit;

################################################################

# rotate pixels
sub mkglyph {
    my $n = shift;

    my $c    = chr($n);
    my @name = ($CHARNAME{$c}, $CHARNAME{sprintf("u+%02X", $n)}, $c,
                sprintf('%03d', $n), sprintf('%04d', $n),
                sprintf("u+%02X", $n), sprintf("U+%04X", $n) );

    my $name;
    my $b;
    for my $x (@name){
        $name = $x;
        # $name = chr($n) if $n > 32 && $n < 127;
        $b = $font{$x};
        last if $b;
    }
    $b ||= [];

    #printf STDERR "n $n, c %s => $name\n", chr($n), $name;

    print "\t";
    for my $x (0 .. $bbx-1){
        my $line = 0;
        for my $y (0 .. $bby-1){
            my $p = ($b->[$y] & (1<<($xbits-$x-1))) ? 1 : 0;
            $line |= $p << $y;
        }

        # little endian
        for (1 .. $chbytes){
            printf "0x%x, ", $line & 0xFF;
            $line >>= 8;
        }

    }

    print "\t// $n\t$name\n";
}

################################################################
__END__
  space
! exclam
" quotedbl
# numbersign
$ dollar
% percent
& ampersand
' quotesingle
( parenleft
) parenright
* asterisk
+ plus
, comma
- hyphen
. period
/ slash
0 zero
1 one
2 two
3 three
4 four
5 five
6 six
7 seven
8 eight
9 nine
: colon
; semicolon
< less
= equal
> greater
? question
@ at
[ bracketleft
\ backslash
] bracketright
^ asciicircum
_ underscore
` grave
{ braceleft
| bar
} braceright
~ asciitilde
u+80	arrowleft
u+81	arrowup
u+82	arrowright
u+83	arrowdown
u+84	arrowupdn
u+85	arrowboth
u+86	uni2196		# NW arrow
u+87	uni2197		# NE arrow
u+88	uni2198		# SE arrow
u+89	uni2199		# SW arrow
u+8A	uni21B0		# up+left
u+8B	uni21B1		# up+right
u+8C	uni21B6		# up+left round
u+8D	uni21B7		# up+right round
u+8E	uni21BA		# ccw arrow
u+8F	uni21BB		# cw arrow
u+90	smileface
u+91	uni2639		# frown
u+92	uni2620		# skull+crossbones
u+93	copyright
u+94	heart
