#!/usr/local/bin/perl
# -*- perl -*-

# Copyright (c) 2011
# Author: Jeff Weisberg <jaw @ tcp4me.com>
# Created: 2011-Dec-04 13:48 (EST)
# Function: build files from config
#
# $Id$

use Getopt::Std;
use POSIX;
use File::Copy;
use strict;

my %opt;
getopts('d:', \%opt);

my $confile = $ARGV[0];
my $dir = $opt{d} || "../build/$confile";
mkdir $dir;
die "cannot create build directory\n" unless -d $dir;


my %fileconf;
my %usefiles;
my @appfiles;
my @appdirs;
my($arch, $variant);

my $ident   = $confile;
my $version = from_file('../src/etc/version');
my $number  = from_file("$dir/number") || 0;
$number ++;
to_file("$dir/number", $number);
conf_files( '../src/etc/files', 0 );

open( CONFH, "> $dir/conf.h" )        || die "cannot open conf.h: $!\n";
open( CONFC, "> $dir/conf.c" )        || die "cannot open conf.c: $!\n";
open( CONFM, "> $dir/makefile.conf" ) || die "cannot open Makefile.conf: $!\n";
open( CONFD, "> $dir/makefile.deps" ) || die "cannot open Makefile.deps: $!\n";

copy( '../src/etc/Makefile', "$dir/Makefile" );


print CONFM "\n# this file is generated automatically - do not edit\n\n";
print CONFD "\n# this file is generated automatically - do not edit\n\n";
print CONFH "\n/* this file is generated automatically - do not edit */\n\n";

print CONFC <<EOM;

/* this file is generated automatically - do not edit */

#include <sys/types.h>
#include <sys/param.h>
#include <conf.h>
#include <nstdio.h>
#include <flash.h>
#include <disk.h>
#include <dev.h>
#include <fs.h>
#include <font.h>

EOM
    ;

my $nflashdev = 0;
my $flashdev = "const struct Flash_Conf flash_device[] = {\n";
my $ndevs = 0;
my $devs = "const struct Device_Conf all_devices[] = {\n";
my $nfsys = 0;
my $fsys = "const struct FSType_Conf filesystems[] = {\n";
my $ndisk = 0;
my $diskdev = "const struct DiskPart_Conf disk_device[] = {\n";
my @font;

my($root, $start, $name, %devs);

while( <> ){
    chop;
    s/#.*//;
    next if /^\s*$/;

    my @f = split;
    my $cmd = $f[0];

    if( $cmd eq "option" ){
	print CONFH "#define $f[1] $f[2]\n";
    }

    elsif( $cmd eq "feature" ){
	print CONFH "#define USE_\U$f[1]\n";
        feature( lc($f[1]), 'feature' );
    }
    elsif( $cmd eq 'files' ){
        # config file
        conf_files( $f[1], 4 );
    }
    elsif( $cmd eq 'srcdir' ){
        push @appdirs, $f[1];
    }
    elsif( $cmd eq 'srcfile' ){
        # app src code
        push @appfiles, $f[1];
    }
    elsif( $cmd eq 'font' ){
        # font fontname
        shift @f;
        push @font, @f;
    }
    elsif( $cmd eq "config" ){
	($root) = /root on\s*([^\s]*)/;
	print CONFH "#define MOUNT_ROOT \"$root\"\n" if $root;

	($start) = /startup in\s*([^\s]*)/;
	print CONFH "#define STARTUPFILE \"$start\"\n" if $start;

        my($console) = /console on\s+([^\s]*)/;
        print CONFH "#define CONSOLE_ON \"$console\"\n" if $console;
    }

    elsif( $cmd eq "flashdev" ){
	$nflashdev ++;
	my( $addr, $size, $blk, $flg, $type ) = (0,0,0,0);

	($addr) = /@\s*([^\s]*)/     if /@/;
	($size) = /size\s*([^\s]*)/  if /size/;
	($blk)  = /block\s*([^\s]*)/ if /block/;
	($flg)  = /flags\s*([^\s]*)/ if /flags/;
	($type) = /type\s*([^\s]*)/  if /type/;


	$flashdev .= "\t{ (void*)$addr, $size, $flg, $blk, \"$f[1]\", \"$type\" },\n";
    }

    elsif( $cmd eq "disk" ){
	$ndisk ++;
	my( $cont, $unit, $part, $flags, $type ) = (0,0,0,0,0);

	($cont)   = /on\s*([^\s]*)/ if /on/;
	($unit)   = /unit\s*([^\s]*)/ if /unit/;
	($part)   = /partition\s*([^\s]*)/ if /partition/;
	($flags)  = /flags\s*([^\s]*)/ if /flags/;
	($type)   = /type\s*([^\s]*)/  if /type/;

	$diskdev .= "\t{ \"$f[1]\", \"$type\", \"$cont\", $unit, $part, $flags },\n";
    }

    elsif( $cmd eq "filesys" ){

	my $type = $f[1];

	$nfsys ++;
	print CONFC "extern int ${type}_init(struct MountEntry *);\n";
	print CONFC "extern int ${type}_ops(int, struct MountEntry *, ...);\n";
	print CONFC "extern FILE* ${type}_open(struct MountEntry *, const char*, const char*);\n";
	$fsys .= "\t{ \"$type\", ${type}_init, ${type}_open, ${type}_ops },\n";

        feature( $type, 'filesystem' );
    }

    elsif( $cmd eq "device" ){
	my $name = $f[1];
	my( $port, $addr, $irq, $flags, $baud, $init ) = (0,0,0,0,0,0);
        my $type = '';
        my $args = '';
        my $unit;

	my ($dev, $n) = $name =~ /(\S*\D+)(\d*)$/;

	($port) = /port\s*([^\s]*)/   if /port/;
	($baud) = /baud\s*([^\s]*)/   if /baud/;
	($irq) = /irq\s*([^\s]*)/     if /irq/;
	($flags) = /flags\s*([^\s]*)/ if /flags/;
	($addr) = /addr\s*([^\s]*)/   if /addr/;
	($init) = /init\s*([^\s]*)/   if /init/;
	($type) = /type\s*([^\s]*)/   if /type/;
	($unit) = /unit\s*([^\s]*)/   if /unit/;
        ($args) = /args\s+([0-9a-fx, ]+)/i if /args/;

        $type ||= $dev;
        $unit = $n unless defined $unit;

	print CONFH "#define USE_\U$type\E\n" unless $devs{$type};

        $devs{ $type } = $unit if $unit > $devs{$type};
	$devs{ $type } ++;
        feature( $type, 'device' );

	$init = $init || "${type}_init";

	print CONFC "extern int $init(struct Device_Conf *);\n";

        if( $n ne "" ){
	    $devs .= "\t{ $unit, $port, $addr, $irq, $baud, $flags, { $args }, $init, ";
	}else{
	    $devs .= "\t{ 0, 0, 0, 0, 0, 0, { $args }, $init, ";
	}
	if( /nodev/ ){
	    $devs .= "0 },\n";
	}else{
	    $devs .= "\"$name\" },\n";
	}
	$ndevs ++;

    }

    elsif( $cmd eq "ident" ){
	$ident = $f[1];
    }

    elsif( $cmd eq 'arch' ){
        $arch = $f[1];
        print CONFH "#define PLATFORM_", uc($arch), "\n";
        print CONFM "CONF_ARCH = $arch\n";

        conf_files( "../src/machdep/$arch/common/etc/files", 2 );
    }
    elsif( $cmd eq 'variant' ){
        $variant = $f[1];
        print CONFH "#define PLATFORM_", uc($variant), "\n";
        print CONFM "CONF_VARIANT = $variant\n";

        conf_files( "../src/machdep/$arch/$variant/etc/files", 3 );
    }
    elsif( $cmd eq 'compile-prefix' ){
        print CONFM "CONF_PREFIX = $f[1]\n";
    }
    elsif( $cmd eq 'compile-flags' ){
        shift @f;
        print CONFM "CONF_FLAGS = @f\n";
    }

    else{
	print STDERR "unrecognized config: $_\n";
	exit -1;
    }
}

################################################################

feature('kern', 'feature');


for my $d (keys %devs){
    print CONFH "#define N_\U$d\E $devs{$d}\n";
}
print CONFH "#define N_FLASHDEV $nflashdev\n";
print CONFH "#define N_DISK $ndisk\n";
print CONFH "#define USE_FILESYS\n" if( $nfsys );


chop(my $whoami = `whoami`);
chop(my $host=`hostname`);
chop(my $pwd = `cd ..;pwd`);
my $date = strftime('%Y-%m-%d %H:%M', localtime());
my $archid = uc($arch . ($variant ? "/$variant" : ''));

print CONFC <<EOM;

const int n_devs = $ndevs;
const int n_flashdev = $nflashdev;
const int n_fsys = $nfsys;
const int n_disk = $ndisk;

$flashdev};
$devs};
$fsys};
$diskdev};

const char ident[]   = "$ident";
const char archid[]  = "$archid";
const char version[] =
	"OS/J5 ($ident) $archid Release $version($number)\\n"
	"Copyright (c) 1999-2015 Jeff Weisberg\\n"
	"Built on $date by $whoami\@$host\\n"
	"Built in $pwd\\n";

EOM

if( -f "../src/machdep/$arch/$variant/etc/link.ld" ){
    print CONFM "LINK_SCRIPT = ../../src/machdep/$arch/$variant/etc/link.ld\n";
}else{
    print CONFM "LINK_SCRIPT = ../../src/machdep/$arch/common/etc/link.ld\n";
}
print CONFM "\n";
if( -f "../src/machdep/$arch/$variant/etc/makefile.inc" ){
    print CONFM qq(.include "../../src/machdep/$arch/$variant/etc/makefile.inc"\n);
}else{
    print CONFM qq(.include "../../src/machdep/$arch/common/etc/makefile.inc"\n);
}


my @objs;
my @srcs;

for my $file (use_files()){
    my($base) = $file =~ m|([^/]+)\.(\S+)$|;

    print CONFD "$base.o: ../../src/$file\n";
    push @objs, "$base.o";
    push @srcs, "../../src/$file";
}

for my $file (@appfiles){
    my($base) = $file =~ m|([^/]+)\.(\S+)$|;

    my $dir = '';
    if( $file !~ m|^/| ){
        # search specified dirs
        for my $d (@appdirs, '../../src'){
            if( -f "$d/$file" ){

                $dir = $d;
                $dir .= '/' unless $dir =~ m|/$|;
                last;
            }
        }

        # no such file? assume the makefile will create it...
        $dir ||= '';
    }

    print CONFD "$base.o: $dir$file\n";
    push @objs, "$base.o";
    push @srcs, "$dir$file";
}

# icky - but backwards compat
if( defined $usefiles{'util/gfxdpy.cc'} ){
    unless(@font){
        @font = qw(5x8 4x6 5x7 5x8 6x10 6x12 9x15 10x20);
    }
}

# unique
my %font;
@font{@font} = @font;

for my $font (keys %font){
    # user dir or sys?

    my($base) = $font =~ m|([^/]+)$|;

    my $dir = '';
    # search specified dirs
    for my $d (@appdirs){
        if( -f "$d/$font.c" ){
            $dir = $d;
            $dir .= '/' unless $dir =~ m|/$|;
            last;
        }
    }

    $dir ||= '../../src/font/';
    print CONFD "$base.o: $dir$font.c\n";
    push @objs, "$base.o";
    push @srcs, "$dir$font.c";
}

print CONFC "extern const struct Font font_$_;\n" for @font;
print CONFC "const struct Font * const fonts[] = {\n";
print CONFC "\t&font_$_,\n" for @font;
print CONFC "};\n\n";

print CONFH "#define N_FONT ", scalar(@font), "\n";

print CONFH "\n";

print CONFM "\nOBJS = conf.o @objs\n\n";
print CONFM "\nSRCS = @srcs\n\n";
close CONFM;
close CONFD;
close CONFC;
close CONFH;



################################################################

sub from_file {
    my $file = shift;

    open(my $f, '<', $file);
    chomp(my $v = <$f>);
    return $v;
}

sub to_file {
    my $file = shift;
    my $data = shift;

    open(my $f, '>', $file);
    print $f $data;
}

sub conf_files {
    my $conf = shift;
    my $prio = shift;

    open(my $f, '<', $conf) || return;

    # feature [cpu|chip]: file file file
    # fileconf{feature} => [ { req, @file } ]

    while(<$f>){
        chop;
        s/#.*$//;
        next if /^\s*$/;
        my($feat, $opt, $file) = /^(\S+)\s*(\S*):\s+(.*)/;
        my @file = split /\s+/, $file;
        push @{$fileconf{$feat}}, { req => $opt, prio => $prio, file => \@file };
    }
}

sub feature {
    my $feat = shift;
    my $catg = shift;

    die "arch not specified\n"   unless $arch;
    die "unknown $catg: $feat\n" if $catg && ! $fileconf{$feat};

    for my $fc ( @{$fileconf{$feat}} ){
        my $req = $fc->{req};
        next if $req && ($req ne $arch) && ($req ne $variant);
        for my $file (@{$fc->{file}}){
            $usefiles{$file} = $fc->{prio};
        }
    }
}

sub use_files {

    my %file;

    for my $file (keys %usefiles){
        my($base) = $file =~ m|.*/([^/]+)\.(\S+)$|;
        my $prio = $usefiles{$file};
        $file{$base} = { file => $file, prio => $prio }
          if !$file{$base} || $prio > $file{$base}{prio};
    }
    return sort map {
        $_->{file};
    } values %file;
}

